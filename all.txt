# Todo app
This is a simple proof of concept app for todos, inspired by 
Trello. There are a number of boards. Each board has a number of orderd lists.
Each list has a number of ordered todos.

## Purpose
The main purpose here is to tinker with ports and adapters architecture.

## Architectural decisions
* Different modules for application and infrastructure ensuring compile time dependency check
* Make illegal states unrepresentable
* Domain model immutable
* No "commands", use cases taks a list of arguments
* No spring boot in applicaton module

## Plan for use cases and endpoints
| Use Case | Description | Endpoint | Method |
|----------|-------------|----------|--------|
| List all boards | View all available boards in the system | /boards | GET |
| Create a board | Create a new board with a title and optional description | /boards | POST |
| Get board details | Retrieve a specific board with all its lists and cards | /boards/:id | GET |
| Update board | Modify board properties like title, description, or color | /boards/:id | PUT |
| Delete board | Remove a board and all its lists and cards | /boards/:id | DELETE |
| Create a list | Add a new list/column to a board | /boards/:boardId/lists | POST |
| Update list | Change a list's properties like its title | /lists/:id | PUT |
| Reorder list | Change a list's position within its board | /lists/:id/position | PUT |
| Delete list | Remove a list and all its cards | /lists/:id | DELETE |
| Create a card | Add a new task card to a list | /lists/:listId/cards | POST |
| Update card | Modify card properties like title, description, or due date | /cards/:id | PUT |
| Move/reorder card | Change a card's position within a list or move it to a different list | /cards/:id/position | PUT |
| Delete card | Remove a card from the system | /cards/:id | DELETE |
package nu.forsenad.todo.domain;

import java.util.ArrayList;
import java.util.List;

public final class Board {
    private final String id;
    private final String name;
    private final List<TodoList> lists;

    public Board(String id, String name, List<TodoList> lists) {
        if (lists == null) {
            throw new IllegalArgumentException("Lists cannot be null");
        }
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Board name cannot be blank");
        }
        if (id == null || id.isBlank()) {
            throw new IllegalArgumentException("Board id cannot be blank");
        }
        this.id = id;
        this.name = name;
        this.lists = List.copyOf(lists);
    }

    public static Board create(String id, String name) {
        return new Board(id, name, List.of());
    }

    // Immutable update method - returns new instance with updated name
    public Board withName(String newName) {
        return new Board(this.id, newName, this.lists);
    }


    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public List<TodoList> getLists() {
        return new ArrayList<>(lists);
    }

    public Board withNewList(TodoList newList) {
        List<TodoList> newLists = new ArrayList<>(this.lists);
        newLists.add(newList);
        return new Board(this.id, this.name, newLists);
    }

    public Board withDeletedList(String listId) {
        List<TodoList> newLists = new ArrayList<>(this.lists);
        newLists = newLists.stream().filter(tl -> !tl.getId().equals(listId)).toList();
        return new Board(this.id, this.name, newLists);
    }


    public Board withRenamedList(String listId, String newTitle) {
        List<TodoList> newLists = lists.stream()
                .map(list ->
                        list.getId().equals(listId)
                                ? list.withTitle(newTitle)
                                : list
                )
                .toList();

        return new Board(this.id, this.name, newLists);
    }

    public Board withMovedList(String listId, int newPosition) {
        if (newPosition < 0 || newPosition >= lists.size()) {
            throw new IllegalArgumentException("Can't move to position " + newPosition);
        }

        int currentIndex = indexOfList(listId);

        if (currentIndex == newPosition) {
            return this; // no-op, still immutable
        }

        List<TodoList> newLists = new ArrayList<>(lists);
        TodoList list = newLists.remove(currentIndex);
        newLists.add(newPosition, list);

        return new Board(this.id, this.name, newLists);
    }

    private int indexOfList(String listId) {
        for (int i = 0; i < lists.size(); i++) {
            if (lists.get(i).getId().equals(listId)) {
                return i;
            }
        }
        throw new IllegalArgumentException("Board " + this.id + " has no list with id " + listId);
    }

    public TodoList getList(String listId) {
        return lists.stream().filter(l -> l.getId().equals(listId)).findFirst().get();
    }

    public Board withReplacedList(TodoList newList) {
        var existingLists = new ArrayList<>(getLists());
        List<TodoList> newLists = existingLists.stream()
                .map(l -> {
                    if (l.getId().equals(newList.getId()))
                        return newList;
                    else
                        return l;
                }).toList();
        return new Board(this.id, this.name, newLists);
    }

    public Board withUpdatedTodo(String todoId, String title, String description) {
    }
}package nu.forsenad.todo.domain;

import java.util.UUID;

public final class Todo {
    private final String id;
    private final String title;
    private final String description;

    public Todo(String id, String title, String description) {
        if (id == null || id.isBlank()) {
            throw new IllegalArgumentException("Todo id cannot be blank");
        }
        if (title == null || title.isBlank()) {
            throw new IllegalArgumentException("Todo title cannot be blank");
        }
        this.id = id;
        this.title = title;
        this.description = description;
    }

    public static Todo create(String title, String description) {
        String id = UUID.randomUUID().toString();
        return new Todo(id, title, description);
    }

    public String getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public Todo withNewFields(String title, String description) {
        return new Todo(this.id, title, description);
    }
}package nu.forsenad.todo.domain;

import java.util.ArrayList;
import java.util.List;

public final class TodoList {
    private final String id;
    private final String title;
    private final List<Todo> todos;

    public TodoList(String id, String title, List<Todo> todos) {
        if (id == null || id.isBlank()) {
            throw new IllegalArgumentException("TodoList id cannot be blank");
        }
        if (title == null || title.isBlank()) {
            throw new IllegalArgumentException("TodoList title cannot be blank");
        }
        if (todos == null) {
            throw new IllegalArgumentException("Todos cannot be null");
        }
        this.id = id;
        this.title = title;
        this.todos = List.copyOf(todos);
    }

    public static TodoList create(String id, String title) {
        return new TodoList(id, title, List.of());
    }

    public String getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public List<Todo> getTodos() {
        return List.copyOf(todos);
    }

    public TodoList withTitle(String newTitle) {
        return create(this.id, newTitle);
    }

    @Override
    public String toString() {
        return "TodoList{" +
                "id='" + id + '\'' +
                ", title='" + title + '\'' +
                ", todos=" + todos +
                '}';
    }

    public TodoList withNewTodo(String title, String description) {
        List<Todo> newList = new ArrayList<>(getTodos());
        newList.add(Todo.create(title, description));
        return new TodoList(this.id, this.title, newList);
    }

    public TodoList withNewTitle(String newTitle) {
        return new TodoList(this.id, newTitle, this.todos);
    }
}package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

import java.util.UUID;

public class CreateBoardUseCase {
    private final BoardRepository boardRepository;

    public CreateBoardUseCase(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    }

    public Board execute(String name) {
        String boardId = UUID.randomUUID().toString();

        Board board = Board.create(
                boardId,
                name
        );

        boardRepository.save(board);

        return board;
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.TodoList;
import nu.forsenad.todo.ports.out.BoardRepository;

import java.util.UUID;

public class CreateListUseCase {
    private final BoardRepository boardRepository;

    public CreateListUseCase(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    }

    public Board execute(String boardId, String name) {
        Board board = boardRepository.findById(boardId);

        TodoList newList = TodoList.create(UUID.randomUUID().toString(), name);
        Board updatedBoard = board.withNewList(newList);

        boardRepository.save(updatedBoard);
        return updatedBoard;
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.TodoList;
import nu.forsenad.todo.ports.out.BoardRepository;

public class CreateTodoUseCase {
    private final BoardRepository boardRepository;

    public CreateTodoUseCase(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    }

    public Board execute(String listId, String title, String description) {
        Board existingBoard = boardRepository.findBoardByListId(listId);
        TodoList existingList = existingBoard.getList(listId);
        TodoList newList = existingList.withNewTodo(title, description);
        Board newBoard = existingBoard.withReplacedList(newList);
        boardRepository.save(newBoard);
        return newBoard;
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

public class DeleteListUseCase {
    private final BoardRepository boardRepository;

    public DeleteListUseCase(BoardRepository boardRepository){
        this.boardRepository = boardRepository;
    }

    public Board execute(String listId) {
        Board existingBoard = boardRepository.findBoardByListId(listId);
        Board newBoard = existingBoard.withDeletedList(listId);
        boardRepository.save(newBoard);
        return newBoard;
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

public class GetBoardDetailsUseCase {
    private final BoardRepository boardRepository;

    public GetBoardDetailsUseCase(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    }

    public Board execute(String boardId) {
        return boardRepository.findById(boardId);
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

import java.util.List;

public class ListAllBoardsUseCase {
    private final BoardRepository boardRepository;

    public ListAllBoardsUseCase(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    }

    public List<Board> execute() {
        return boardRepository.findAll();
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

public class MoveListWithinBoardUseCase {
    private final BoardRepository boardRepository;

    public MoveListWithinBoardUseCase(
            BoardRepository boardRepository
    ) {
        this.boardRepository = boardRepository;
    }

    //Reorders lists on the board.
    //Positions are 0-indexed
    public Board execute(String listId, int newPosition) {
        Board board = boardRepository.findBoardByListId(listId);

        Board updatedBoard = board.withMovedList(listId, newPosition);

        boardRepository.save(updatedBoard);
        return updatedBoard;
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

public class UpdateBoardUseCase {
    private final BoardRepository boardRepository;

    public UpdateBoardUseCase(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    }

    public Board execute(String boardId, String newName) {
        if (!boardRepository.exists(boardId)) {
            throw new IllegalArgumentException("Board with id " + boardId + " does not exist");
        }

        Board existingBoard = boardRepository.findById(boardId);
        Board updatedBoard = existingBoard.withName(newName);

        boardRepository.save(updatedBoard);

        return updatedBoard;
    }
}package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

public class UpdateCardUseCase {
    private final BoardRepository boardRepository;

    public UpdateCardUseCase(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    }

    public Board execute(String todoId, String title, String description) {
        Board existing = boardRepository.findBoardByTodoId(todoId);
        Board updated = existing.withUpdatedTodo(todoId, title, description);
        boardRepository.save(updated);
        return updated;
    }
}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;

public class UpdateListTitleUseCase {
    private final BoardRepository boardRepository;

    public UpdateListTitleUseCase(
            BoardRepository boardRepository
    ) {
        this.boardRepository = boardRepository;
    }

    public Board execute(String listId, String newTitle) {
        Board existingBoard = boardRepository.findBoardByListId(listId);

        Board updatedBoard = existingBoard.withRenamedList(listId, newTitle);

        boardRepository.save(updatedBoard);
        return updatedBoard;
    }
}package nu.forsenad.todo.ports.out;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.Todo;

import java.util.List;

public interface BoardRepository {
    void save(Board board);

    boolean exists(String boardId);

    Board findById(String boardId);

    List<Board> findAll();

    Board findBoardByListId(String listId);

    Board findBoardByTodoId(String todoId);

}package nu.forsenad.todo.ports.out;

import nu.forsenad.todo.domain.Todo;

import java.util.List;

public interface TodoRepository {
    void save(Todo board);

    boolean exists(String todoId);

    Todo findById(String todoId);

    List<Todo> findAll();
    
    Todo findTodoByid(String todoId);
}package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.ports.out.BoardRepository;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
class CreateBoardUseCaseTest {
    @Mock
    BoardRepository boardRepository;

    @Test
    void should_persist_ok() {
        CreateBoardUseCase sut = new CreateBoardUseCase(boardRepository);

        sut.execute("Test board");

        ArgumentCaptor<Board> captor = ArgumentCaptor.forClass(Board.class);
        verify(boardRepository).save(captor.capture());

        Board saved = captor.getValue();
        assertThat(saved.getName()).isEqualTo("Test board");
        assertThat(saved.getLists()).isEmpty();
        assertThat(saved.getId()).isNotEmpty();
    }

    @Test
    void should_reject_null_name() {
        CreateBoardUseCase sut = new CreateBoardUseCase(boardRepository);
        Assertions.assertThrows(IllegalArgumentException.class, () ->
                sut.execute(null)
        );
    }

    @Test
    void should_reject_blank_name() {
        CreateBoardUseCase sut = new CreateBoardUseCase(boardRepository);
        Assertions.assertThrows(IllegalArgumentException.class, () ->
                sut.execute(" ")
        );
    }

}package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.Todo;
import nu.forsenad.todo.domain.TodoList;
import nu.forsenad.todo.ports.out.BoardRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CreateTodoUseCaseTest {

    @Mock
    BoardRepository boardRepository;

    CreateTodoUseCase sut;

    Board board;
    TodoList list;

    @BeforeEach
    void setUp() {
        sut = new CreateTodoUseCase(boardRepository);

        list = TodoList.create("list-1", "My List");
        board = Board.create("board-1", "My Board")
                .withNewList(list);
    }

    @Test
    void should_add_todo_to_list() {
        when(boardRepository.findBoardByListId("list-1"))
                .thenReturn(board);

        Board result = sut.execute("list-1", "Buy milk", "Get 2% milk from store");

        ArgumentCaptor<Board> captor = ArgumentCaptor.forClass(Board.class);
        verify(boardRepository).save(captor.capture());

        Board saved = captor.getValue();
        TodoList updatedList = saved.getList("list-1");

        assertThat(updatedList.getTodos()).hasSize(1);
        Todo todo = updatedList.getTodos().get(0);
        assertThat(todo.getTitle()).isEqualTo("Buy milk");
        assertThat(todo.getDescription()).isEqualTo("Get 2% milk from store");
        assertThat(todo.getId()).isNotEmpty();
    }

    @Test
    void should_preserve_existing_todos() {
        TodoList listWithTodo = list.withNewTodo("Existing task", "Description");
        Board boardWithTodo = board.withReplacedList(listWithTodo);

        when(boardRepository.findBoardByListId("list-1"))
                .thenReturn(boardWithTodo);

        Board result = sut.execute("list-1", "New task", "New description");

        TodoList updatedList = result.getList("list-1");
        assertThat(updatedList.getTodos()).hasSize(2);
        assertThat(updatedList.getTodos())
                .extracting(Todo::getTitle)
                .containsExactly("Existing task", "New task");
    }

    @Test
    void should_allow_null_description() {
        when(boardRepository.findBoardByListId("list-1"))
                .thenReturn(board);

        Board result = sut.execute("list-1", "Task without description", null);

        TodoList updatedList = result.getList("list-1");
        assertThat(updatedList.getTodos()).hasSize(1);
        assertThat(updatedList.getTodos().get(0).getDescription()).isNull();
    }

    @Test
    void should_reject_null_title() {
        when(boardRepository.findBoardByListId("list-1"))
                .thenReturn(board);

        assertThatThrownBy(() -> sut.execute("list-1", null, "Description"))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("title");

        verify(boardRepository, never()).save(any());
    }

    @Test
    void should_reject_blank_title() {
        when(boardRepository.findBoardByListId("list-1"))
                .thenReturn(board);

        assertThatThrownBy(() -> sut.execute("list-1", "  ", "Description"))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("title");

        verify(boardRepository, never()).save(any());
    }

    @Test
    void should_throw_when_list_not_found() {
        when(boardRepository.findBoardByListId("nonexistent-list"))
                .thenThrow(new RuntimeException("List not found"));

        assertThatThrownBy(() ->
                sut.execute("nonexistent-list", "Task", "Description"))
                .isInstanceOf(RuntimeException.class);

        verify(boardRepository, never()).save(any());
    }

    @Test
    void should_preserve_other_lists_on_board() {
        TodoList list2 = TodoList.create("list-2", "Other List");
        Board boardWithMultipleLists = board.withNewList(list2);

        when(boardRepository.findBoardByListId("list-1"))
                .thenReturn(boardWithMultipleLists);

        Board result = sut.execute("list-1", "New task", "Description");

        assertThat(result.getLists()).hasSize(2);
        assertThat(result.getLists())
                .extracting(TodoList::getId)
                .containsExactly("list-1", "list-2");

        // Only list-1 should have the new todo
        assertThat(result.getList("list-1").getTodos()).hasSize(1);
        assertThat(result.getList("list-2").getTodos()).isEmpty();
    }
}package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.TodoList;
import nu.forsenad.todo.ports.out.BoardRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class DeleteListUseCaseTest {

    @Mock
    BoardRepository boardRepository;

    DeleteListUseCase sut;

    TodoList l1;
    TodoList l2;
    Board board;

    @BeforeEach
    void setUp() {
        sut = new DeleteListUseCase(boardRepository);

        l1 = TodoList.create("l1", "List 1");
        l2 = TodoList.create("l2", "List 2");

        board = Board.create("b1", "Board 1")
                .withNewList(l1)
                .withNewList(l2);
    }

    @Test
    public void list_is_removed() {
        when(boardRepository.findBoardByListId("l1"))
                .thenReturn(board);
        Board actual = sut.execute("l1");
        assertThat(actual.getLists()).containsExactly(l2);
    }

}package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.TodoList;
import nu.forsenad.todo.ports.out.BoardRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class MoveListWithinBoardUseCaseTest {

    @Mock
    BoardRepository boardRepository;

    MoveListWithinBoardUseCase sut;

    TodoList l1;
    TodoList l2;
    Board board;

    @BeforeEach
    void setUp() {
        sut = new MoveListWithinBoardUseCase(boardRepository);

        l1 = TodoList.create("l1", "List 1");
        l2 = TodoList.create("l2", "List 2");

        board = Board.create("b1", "Board 1")
                .withNewList(l1)
                .withNewList(l2);
    }

    @ParameterizedTest
    @CsvSource({
            "l2, 0, l2, l1",
            "l1, 1, l2, l1"
    })
    void moves_list_to_new_position(
            String listId,
            int newPosition,
            String firstExpected,
            String secondExpected
    ) {
        when(boardRepository.findBoardByListId(listId))
                .thenReturn(board);

        Board result = sut.execute(listId, newPosition);

        assertThat(result.getLists())
                .extracting(TodoList::getId)
                .containsExactly(firstExpected, secondExpected);

        verify(boardRepository).save(result);
    }

    @Test
    void moving_list_to_same_position_returns_same_order() {
        when(boardRepository.findBoardByListId("l1"))
                .thenReturn(board);

        Board result = sut.execute("l1", 0);

        assertThat(result.getLists())
                .extracting(TodoList::getId)
                .containsExactly("l1", "l2");

        verify(boardRepository).save(result);
    }
    @Test
    void moving_list_to_negative_position_throws() {
        when(boardRepository.findBoardByListId("l1"))
                .thenReturn(board);

        assertThatThrownBy(() -> sut.execute("l1", -1))
                .isInstanceOf(IllegalArgumentException.class);

        verify(boardRepository, never()).save(any());
    }

    @Test
    void moving_list_past_end_throws() {
        when(boardRepository.findBoardByListId("l1"))
                .thenReturn(board);

        assertThatThrownBy(() -> sut.execute("l1", 2))
                .isInstanceOf(IllegalArgumentException.class);

        verify(boardRepository, never()).save(any());
    }

    @Test
    void moving_unknown_list_throws() {
        when(boardRepository.findBoardByListId("l3"))
                .thenThrow(new RuntimeException("l3"));

        assertThatThrownBy(() -> sut.execute("l3", 0))
                .isInstanceOf(RuntimeException.class);

        verify(boardRepository, never()).save(any());
    }


}
package nu.forsenad.todo.ports.in;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.TodoList;
import nu.forsenad.todo.ports.out.BoardRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UpdateBoardUseCaseTest {

    @Mock
    BoardRepository boardRepository;

    @Test
    void should_update_board_name() {
        // Given
        String boardId = "board-123";
        Board existingBoard = Board.create(boardId, "Old Name");
        when(boardRepository.exists(boardId)).thenReturn(true);
        when(boardRepository.findById(boardId)).thenReturn(existingBoard);

        UpdateBoardUseCase sut = new UpdateBoardUseCase(boardRepository);

        // When
        Board result = sut.execute(boardId, "New Name");

        // Then
        ArgumentCaptor<Board> captor = ArgumentCaptor.forClass(Board.class);
        verify(boardRepository).save(captor.capture());

        Board saved = captor.getValue();
        assertThat(saved.getId()).isEqualTo(boardId);
        assertThat(saved.getName()).isEqualTo("New Name");
        assertThat(saved.getLists()).isEmpty();

        assertThat(result.getName()).isEqualTo("New Name");
    }

    @Test
    void should_reject_nonexistent_board() {
        when(boardRepository.exists("nonexistent")).thenReturn(false);

        UpdateBoardUseCase sut = new UpdateBoardUseCase(boardRepository);

        assertThrows(IllegalArgumentException.class, () ->
                sut.execute("nonexistent", "New Name")
        );
    }

    @Test
    void should_reject_blank_name() {
        String boardId = "board-123";
        Board existingBoard = Board.create(boardId, "Old Name");
        when(boardRepository.exists(boardId)).thenReturn(true);
        when(boardRepository.findById(boardId)).thenReturn(existingBoard);

        UpdateBoardUseCase sut = new UpdateBoardUseCase(boardRepository);

        assertThrows(IllegalArgumentException.class, () ->
                sut.execute(boardId, "  ")
        );
    }

    @Test
    void should_preserve_existing_lists() {
        // Given
        String boardId = "board-123";
        Board existingBoard = new Board(boardId, "Old Name",
                java.util.List.of(new TodoList("a", "b", List.of())));
        when(boardRepository.exists(boardId)).thenReturn(true);
        when(boardRepository.findById(boardId)).thenReturn(existingBoard);

        UpdateBoardUseCase sut = new UpdateBoardUseCase(boardRepository);

        // When
        Board result = sut.execute(boardId, "New Name");

        // Then
        assertThat(result.getLists()).isEqualTo(existingBoard.getLists());
    }
}package nu.forsenad.todo.infrastructure.config;

import nu.forsenad.todo.ports.in.*;
import nu.forsenad.todo.ports.out.BoardRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class UseCaseConfig {

    @Bean
    public CreateBoardUseCase createBoardUseCase(BoardRepository boardRepository) {
        return new CreateBoardUseCase(boardRepository);
    }

    @Bean
    public UpdateBoardUseCase updateBoardUseCase(BoardRepository boardRepository) {
        return new UpdateBoardUseCase(boardRepository);
    }

    @Bean
    public ListAllBoardsUseCase listAllBoardsUseCase(BoardRepository boardRepository) {
        return new ListAllBoardsUseCase(boardRepository);
    }

    @Bean
    public GetBoardDetailsUseCase getBoardDetailsUseCase(BoardRepository boardRepository) {
        return new GetBoardDetailsUseCase(boardRepository);
    }

    @Bean
    public CreateListUseCase createListUseCase(BoardRepository boardRepository) {
        return new CreateListUseCase(boardRepository);
    }

    @Bean
    public DeleteListUseCase deleteListUseCase(BoardRepository boardRepository) {
        return new DeleteListUseCase(boardRepository);
    }

    @Bean
    public UpdateListTitleUseCase updateListTitleUseCase(BoardRepository boardRepository) {
        return new UpdateListTitleUseCase(boardRepository);
    }

    @Bean
    public MoveListWithinBoardUseCase moveListWithinBoardUseCase(BoardRepository boardRepository) {
        return new MoveListWithinBoardUseCase(boardRepository);
    }

    @Bean
    public CreateTodoUseCase createTodoUseCase(BoardRepository boardRepository) {
        return new CreateTodoUseCase(boardRepository);
    }
}package nu.forsenad.todo.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:5173", "http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}package nu.forsenad.todo.infrastructure.inbound.rest;

import io.swagger.v3.oas.annotations.Operation;
import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.infrastructure.inbound.rest.model.BoardModel;
import nu.forsenad.todo.infrastructure.inbound.rest.model.CreateUpdateBoardRequest;
import nu.forsenad.todo.ports.in.CreateBoardUseCase;
import nu.forsenad.todo.ports.in.GetBoardDetailsUseCase;
import nu.forsenad.todo.ports.in.ListAllBoardsUseCase;
import nu.forsenad.todo.ports.in.UpdateBoardUseCase;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/boards")
public class BoardController {

    private final CreateBoardUseCase createBoardUseCase;
    private final UpdateBoardUseCase updateBoardUseCase;
    private final GetBoardDetailsUseCase getBoardDetailsUseCase;
    private final ListAllBoardsUseCase listAllBoardsUseCase;

    public BoardController(CreateBoardUseCase createBoardUseCase,
                           UpdateBoardUseCase updateBoardUseCase,
                           GetBoardDetailsUseCase getBoardDetailsUseCase,
                           ListAllBoardsUseCase listAllBoardsUseCase) {
        this.createBoardUseCase = createBoardUseCase;
        this.updateBoardUseCase = updateBoardUseCase;
        this.getBoardDetailsUseCase = getBoardDetailsUseCase;
        this.listAllBoardsUseCase = listAllBoardsUseCase;
    }

    // GET /boards - List all boards
    @GetMapping
    @Operation(summary="List all boards")
    public ResponseEntity<List<BoardModel>> listBoards() {
        List<Board> boards = listAllBoardsUseCase.execute();
        List<BoardModel> models = boards.stream()
                .map(BoardModel::new)
                .toList();
        return ResponseEntity.ok(models);
    }

    // GET /boards/{id} - Get board details
    @Operation(summary = "Get one board")
    @GetMapping("/{id}")
    public ResponseEntity<BoardModel> getBoardDetails(@PathVariable String id) {
        Board board = getBoardDetailsUseCase.execute(id);
        return ResponseEntity.ok(new BoardModel(board));
    }

    // POST /boards - Create new board
    @Operation(summary="Create new board")
    @PostMapping
    public ResponseEntity<BoardModel> createBoard(@RequestBody CreateUpdateBoardRequest request) {
        Board newBoard = createBoardUseCase.execute(request.getName());
        return ResponseEntity.ok(new BoardModel(newBoard));
    }

    // PUT /boards/{id} - Update board
    @Operation(summary = "Change name of board")
    @PutMapping("/{id}")
    public ResponseEntity<BoardModel> updateBoard(
            @PathVariable String id,
            @RequestBody CreateUpdateBoardRequest request) {
        Board updatedBoard = updateBoardUseCase.execute(id, request.getName());
        return ResponseEntity.ok(new BoardModel(updatedBoard));
    }
}package nu.forsenad.todo.infrastructure.inbound.rest;

import io.swagger.v3.oas.annotations.Operation;
import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.TodoList;
import nu.forsenad.todo.infrastructure.inbound.rest.model.*;
import nu.forsenad.todo.ports.in.CreateListUseCase;
import nu.forsenad.todo.ports.in.DeleteListUseCase;
import nu.forsenad.todo.ports.in.MoveListWithinBoardUseCase;
import nu.forsenad.todo.ports.in.UpdateListTitleUseCase;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/lists")
public class ListController {

    private final CreateListUseCase createListUseCase;
    private final DeleteListUseCase deleteListUseCase;
    private final UpdateListTitleUseCase updateListTitleUseCase;
    private final MoveListWithinBoardUseCase moveListWithinBoardUseCase;

    public ListController(CreateListUseCase createListUseCase,
                          DeleteListUseCase deleteListUseCase,
                          UpdateListTitleUseCase updateListTitleUseCase,
                          MoveListWithinBoardUseCase moveListWithinBoardUseCase) {
        this.createListUseCase = createListUseCase;
        this.deleteListUseCase = deleteListUseCase;
        this.updateListTitleUseCase = updateListTitleUseCase;
        this.moveListWithinBoardUseCase = moveListWithinBoardUseCase;
    }

    // POST /lists - Create new list on a board
    @Operation(summary = "Create new list on a board")
    @PostMapping
    public ResponseEntity<BoardModel> createList(@RequestBody CreateListRequest request) {
        Board updatedBoard = createListUseCase.execute(request.getBoardId(), request.getName());
        return ResponseEntity.ok(new BoardModel(updatedBoard));
    }

    // DELETE /lists/{id} - Delete a list
    @Operation(summary = "Delete a list")
    @DeleteMapping("/{id}")
    public ResponseEntity<BoardModel> deleteList(@PathVariable String id) {
        Board updatedBoard = deleteListUseCase.execute(id);
        return ResponseEntity.ok(new BoardModel(updatedBoard));
    }

    // PUT /lists/{id} - Update list title
    @Operation(summary="Update list title")
    @PutMapping("/{id}")
    public ResponseEntity<TodoListModel> updateListTitle(
            @PathVariable String id,
            @RequestBody UpdateListRequest request) {
        TodoList updatedBoard = updateListTitleUseCase.execute(id, request.getTitle());
        return ResponseEntity.ok(new TodoListModel(updatedBoard));
    }

    // PUT /lists/{id}/move - Move list to new position
    @Operation(summary = "Move a list within a board. Positions are 0-indexed.")
    @PutMapping("/{id}/move")
    public ResponseEntity<BoardModel> moveList(
            @PathVariable String id,
            @RequestBody MoveListRequest request) {
        Board updatedBoard = moveListWithinBoardUseCase.execute(id, request.getPosition());
        return ResponseEntity.ok(new BoardModel(updatedBoard));
    }
}package nu.forsenad.todo.infrastructure.inbound.rest.model;

import nu.forsenad.todo.domain.Board;

import java.util.List;

public class BoardModel {
    String id;
    String name;
    List<TodoListModel> lists;

    public BoardModel(Board domainBoard) {
        this.id = domainBoard.getId();
        this.name = domainBoard.getName();
        this.lists = domainBoard.getLists()
                .stream()
                .map(TodoListModel::new)
                .toList();
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public List<TodoListModel> getLists() {
        return lists;
    }
}
package nu.forsenad.todo.infrastructure.inbound.rest.model;

// CreateListRequest.java
public class CreateListRequest {
    private String boardId;
    private String name;

    public String getBoardId() {
        return boardId;
    }

    public void setBoardId(String boardId) {
        this.boardId = boardId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

package nu.forsenad.todo.infrastructure.inbound.rest.model;

// CreateTodoRequest.java
public class CreateTodoRequest {
    private String listId;
    private String title;
    private String description;

    public String getListId() {
        return listId;
    }

    public void setListId(String listId) {
        this.listId = listId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}
package nu.forsenad.todo.infrastructure.inbound.rest.model;

public class CreateUpdateBoardRequest {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}
package nu.forsenad.todo.infrastructure.inbound.rest.model;

// MoveListRequest.java
public class MoveListRequest {
    private int position;

    public int getPosition() {
        return position;
    }

    public void setPosition(int position) {
        this.position = position;
    }
}
package nu.forsenad.todo.infrastructure.inbound.rest.model;

import nu.forsenad.todo.domain.TodoList;

import java.util.List;

public class TodoListModel {
    private String id;
    private String title;
    private List<TodoModel> todos;

    public TodoListModel(TodoList domainList) {
        this.id = domainList.getId();
        this.title = domainList.getTitle();
        this.todos = domainList.getTodos().stream()
                .map(TodoModel::new)
                .toList();
    }

    public String getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public List<TodoModel> getTodos() {
        return todos;
    }
}package nu.forsenad.todo.infrastructure.inbound.rest.model;

import nu.forsenad.todo.domain.Todo;

class TodoModel {
    private String id;
    private String title;
    private String description;

    public TodoModel(Todo domainTodo) {
        this.id = domainTodo.getId();
        this.title = domainTodo.getTitle();
        this.description = domainTodo.getDescription();
    }

    public String getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }
}package nu.forsenad.todo.infrastructure.inbound.rest.model;

// UpdateListRequest.java
public class UpdateListRequest {
    private String title;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}
package nu.forsenad.todo.infrastructure.inbound.rest;

import io.swagger.v3.oas.annotations.Operation;
import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.infrastructure.inbound.rest.model.BoardModel;
import nu.forsenad.todo.infrastructure.inbound.rest.model.CreateTodoRequest;
import nu.forsenad.todo.ports.in.CreateTodoUseCase;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/todos")
public class TodoController {

    private final CreateTodoUseCase createTodoUseCase;

    public TodoController(CreateTodoUseCase createTodoUseCase) {
        this.createTodoUseCase = createTodoUseCase;
    }

    // POST /todos - Create new todo in a
    @Operation(summary = "Create new todo")
    @PostMapping
    public ResponseEntity<BoardModel> createTodo(@RequestBody CreateTodoRequest request) {
        Board updatedBoard = createTodoUseCase.execute(
                request.getListId(),
                request.getTitle(),
                request.getDescription()
        );
        return ResponseEntity.ok(new BoardModel(updatedBoard));
    }
}package nu.forsenad.todo.infrastructure.outbound.entity;

import jakarta.persistence.*;
import nu.forsenad.todo.domain.Board;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Entity
@Table(name = "boards")
public class BoardEntity {

    @Id
    private String id;

    private String name;

    @Version
    private long version;

    @OneToMany(mappedBy = "board", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ListEntity> lists = new ArrayList<>();

    protected BoardEntity() {
        // JPA requires a no-arg constructor
    }

    // Map from domain to entity
    public static BoardEntity fromDomain(Board board) {
        BoardEntity entity = new BoardEntity();
        entity.id = board.getId();
        entity.name = board.getName();
        entity.lists = board.getLists().stream()
                .map(ListEntity::fromDomain)
                .collect(Collectors.toList());
        // Set bidirectional relationship
        entity.lists.forEach(list -> list.setBoard(entity));
        return entity;
    }

    // Map from entity to domain
    public Board toDomain() {
        return new Board(
                this.id,
                this.name,
                this.lists.stream()
                        .map(ListEntity::toDomain)
                        .toList()
        );
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public long getVersion() {
        return version;
    }

    public List<ListEntity> getLists() {
        return lists;
    }
}package nu.forsenad.todo.infrastructure.outbound.entity;

import jakarta.persistence.*;
import nu.forsenad.todo.domain.TodoList;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "lists")
public class ListEntity {
    @Id
    private String id;

    private String title;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "board_id")
    private BoardEntity board;

    @OneToMany(mappedBy = "list", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TodoEntity> todos = new ArrayList<>();

    protected ListEntity() {
        // JPA requires no-arg constructor
    }

    public static ListEntity fromDomain(TodoList todoList) {
        ListEntity entity = new ListEntity();
        entity.id = todoList.getId();
        entity.title = todoList.getTitle();
        entity.todos = todoList.getTodos().stream()
                .map(TodoEntity::fromDomain)
                .toList();
        entity.todos.forEach(todo -> todo.setList(entity));
        return entity;
    }

    public void setBoard(BoardEntity board) {
        this.board = board;
    }

    public TodoList toDomain() {
        return new TodoList(
                this.id,
                this.title,
                this.todos.stream()
                        .map(TodoEntity::toDomain)
                        .toList()
        );
    }
}package nu.forsenad.todo.infrastructure.outbound.entity;

import jakarta.persistence.*;
import nu.forsenad.todo.domain.Todo;

@Entity
@Table(name = "todos")
public class TodoEntity {
    @Id
    private String id;

    private String title;

    @Column(length = 1000)
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "list_id")
    private ListEntity list;

    protected TodoEntity() {
        // JPA requires no-arg constructor
    }

    public static TodoEntity fromDomain(Todo todo) {
        TodoEntity entity = new TodoEntity();
        entity.id = todo.getId();
        entity.title = todo.getTitle();
        entity.description = todo.getDescription();
        return entity;
    }

    public void setList(ListEntity list) {
        this.list = list;
    }

    public Todo toDomain() {
        return new Todo(
                this.id,
                this.title,
                this.description
        );
    }
}package nu.forsenad.todo.infrastructure.outbound.repo;

import nu.forsenad.todo.domain.Board;
import nu.forsenad.todo.domain.Todo;
import nu.forsenad.todo.infrastructure.outbound.entity.BoardEntity;
import nu.forsenad.todo.ports.out.BoardRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class BoardRepositoryImpl implements BoardRepository {

    private final SpringDataBoardRepository jpaRepository;

    public BoardRepositoryImpl(SpringDataBoardRepository jpaRepository) {
        this.jpaRepository = jpaRepository;
    }

    @Override
    public void save(Board board) {
        BoardEntity entity = BoardEntity.fromDomain(board);
        jpaRepository.save(entity);
    }

    @Override
    public boolean exists(String boardId) {
        return jpaRepository.existsById(boardId);
    }

    @Override
    public Board findById(String boardId) {
        return jpaRepository.findByIdWithLists(boardId)
                .map(BoardEntity::toDomain)
                .orElseThrow(() -> new IllegalArgumentException("Board not found: " + boardId));
    }

    @Override
    public List<Board> findAll() {
        return jpaRepository.findAll().stream()
                .map(BoardEntity::toDomain)
                .toList();
    }

    @Override
    public Board findBoardByListId(String listId) {
        return jpaRepository.findBoardByListId(listId)
                .map(BoardEntity::toDomain)
                .orElseThrow(() -> new IllegalArgumentException("Board not found for list: " + listId));
    }

    @Override
    public Board findBoardByTodoId(String todoId) {
        return jpaRepository.findBoardByTodoId(todoId).map(BoardEntity::toDomain)
                .orElseThrow(() -> new IllegalArgumentException("Board not found for todo: " + todoId));
    }


}package nu.forsenad.todo.infrastructure.outbound.repo;
import nu.forsenad.todo.infrastructure.outbound.entity.BoardEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.Optional;

public interface SpringDataBoardRepository extends JpaRepository<BoardEntity, String> {

    Optional<BoardEntity> findBoardByListId(@Param("listId") String listId);

    Optional<BoardEntity> findBoardByTodoId(@Param("todoId") String todoId);
}package nu.forsenad.todo.infrastructure;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TodoApplication {

	public static void main(String[] args) {
		SpringApplication.run(TodoApplication.class, args);
	}

}
package archtest;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaModifier;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.methods;

/**
 * ArchUnit test to verify domain model immutability.
 *
 * Based on the architectural decision that the domain model should be immutable.
 */
class DomainImmutabilityArchTest {

    private static JavaClasses domainClasses;

    @BeforeAll
    static void importClasses() {
        domainClasses = new ClassFileImporter()
                .importPackages("nu.forsenad.todo.domain");
    }

    @Test
    void allInstanceFieldsShouldBeFinal() {
        ArchRule rule = fields()
                .that().areDeclaredInClassesThat().resideInAPackage("..domain..")
                .and().areNotStatic()
                .should().beFinal()
                .because("all domain objects should be immutable with final fields");

        rule.check(domainClasses);
    }

    @Test
    void domainClassesShouldBeFinal() {
        ArchRule rule = classes()
                .that().resideInAPackage("..domain..")
                .and().areNotInterfaces()
                .and().areNotEnums()
                .should().haveModifier(JavaModifier.FINAL)
                .because("domain classes should be final to ensure complete immutability");

        rule.check(domainClasses);
    }

    @Test
    void domainClassesShouldNotHaveSetters() {
        ArchRule noSettersRule = methods()
                .that().areDeclaredInClassesThat().resideInAPackage("..domain..")
                .and().areNotStatic()
                .and().arePublic()
                .should().haveNameNotMatching("set[A-Z].*")
                .because("immutable objects should not have setter methods");

        noSettersRule.check(domainClasses);
    }
}package nu.forsenad.todo.infrastructure;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import nu.forsenad.todo.infrastructure.outbound.entity.BoardEntity;
import nu.forsenad.todo.infrastructure.outbound.repo.SpringDataBoardRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

import static io.restassured.RestAssured.given;
import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.Matchers.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
class BoardControllerIntegrationTest {

    @LocalServerPort
    private int port;

    @Autowired
    SpringDataBoardRepository boardRepository;

    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        boardRepository.deleteAll();
    }

    @Test
    @Transactional
    void shouldCreateBoardAndPersistToDatabase() {
        // Given
        String boardName = "My Test Board";

        // When
        String boardId = given()
                .contentType(ContentType.JSON)
                .body("{\"name\":\"" + boardName + "\"}")
                .when()
                .post("/boards")
                .then()
                .statusCode(200)
                .body("name", equalTo(boardName))
                .body("id", notNullValue())
                .body("lists", empty())
                .extract()
                .path("id");

        // Then
        Optional<BoardEntity> savedBoard = boardRepository.findById(boardId);

        assertThat(savedBoard).isPresent();
        assertThat(savedBoard.get().getName()).isEqualTo(boardName);
        assertThat(savedBoard.get().getLists()).isEmpty();
    }
}package nu.forsenad.todo.infrastructure;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TodoApplicationTests {

	@Test
	void contextLoads() {
	}

}
